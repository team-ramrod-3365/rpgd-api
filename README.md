# rpgd-api
RPG Data as a Service is a RESTful API that allows users to store and manipulate data for role playing games.

## Abstract
RPG Data as a Service, or RPGD, is RESTful API designed to allow users to perform CRUD (Create, Read, Update, Delete) operations on role playing game data stored in a relational database. These operations are exposed through a REST (Representational State Transfer) interface, enabling users to perform these actions utilizing HTTP verbs over a network connection. This abstraction is particularly useful in that it allows users to access the data without forcing them to use a particular technology to do so, other than HTTP. In other words, any HTTP client can be used to interact with the data. There are many popular HTTP clients to choose from, such as curl or Postman, as well as HTTP client libraries such as Requests for Python, Apache HttpClient for Java, and Axios for JavaScript.

This software is designed to be used by anyone that needs to store, retrieve, and manipulate data used by role playing games or role playing game tooling. Another advantage of its HTTP abstraction layer is many different types of software systems can utilize it. For example, RPGD, could be used to build an electronic role playing game built to run as a desktop or browser-based application. Alternatively, it could also be used to create a web-based character builder, or store information for a mobile application designed to let dungeon masters of the popular game Dungeons and Dragons pick encounters at random for players. This flexibility and decoupling is the goal of the project.

Technology choices for this application are the following:
- Programming Language: Java
- Web Framework: Spring MVC
- Database Framework: Spring Data JPA
- Database: PostgreSQL
- Tooling: Docker

The current implemented featureset allows for full CRUD operations to be executed on the `/weapons` resource. Data for this resource is stored in the weapons table in the relational database backing the application. Future features will be added to include armor, items, monsters, and player character data.

The first feature allows users to create a weapon entry in the weapons table by executing a `POST` HTTP operation on the `/weapons` endpoint, passing a JSON (JavaScript Object Notation) payload in the body with the `Content-Type` header set to `application/json`. The application response with a 201 Created HTTP code with a Location header with the stub of the UUID of the weapon resource created. This stub can be appended to the endpoint to fetch the entry the user has created, such as `http://localhost:8080/weapons/01c5cb0c-ad18-4e7c-8e7e-9799b27476a3`. Note the Location header includes a UUID (Universally Unique Identifier) which uniquely identifies the resource created. The UUID is automatically generated by the system, and is used as the primary key for the weapons table. This automatic generation follows a REST convention that resources created using the `POST` HTTP verb should generate an identifier while resources created using a PUT are idempotent and the identifier is chosen by the user. Below is an example request and response.

Example Using cURL
```
curl -vvv -X POST \
-H "Content-Type: application/json" \
-d '{"name": "test", "type": "sword", "description": "blah", "attackPower": 1.0, "attackType": "slashing", "specialAbility": "none", "weight": 10.0}' \
http://localhost:8080/weapons
```

Request
```
POST http://localhost:8080/weapons
Content-Type: application/json

{
    "name": "test",
    "type": "sword",
    "description": "whatever",
    "attackPower": 1.0,
    "attackType": "slashing",
    "specialAbility": "none",
    "weight": 10.0
}
```

Response
```
HTTP/1.1 201
Location: /01c5cb0c-ad18-4e7c-8e7e-9799b27476a3
Content-Type: text/plain;charset=UTF-8
Content-Length: 0
Date: Fri, 14 Feb 2020 03:21:54 GMT
```

The second feature allows users to fetch or read a specific weapon from the database table by executing a `GET` HTTP operation on the `/weapons/{weaponId}` endpoint, setting the `Accept` header to `application/json`. The application responds with a 200 OK HTTP code and a JSON response body of the weapon data stored in the database. Note that the response body includes the UUID in the `id` field. Below is an example request and response.

Example Using cURL
```
curl -vvv -X GET \
-H "Accept: application/json" \
http://localhost:8080/weapons/01c5cb0c-ad18-4e7c-8e7e-9799b27476a3
```

Request
```
GET http://localhost:8080/weapons/01c5cb0c-ad18-4e7c-8e7e-9799b27476a3
Accept: application/json
```

Response
```
HTTP/1.1 200
Content-Type: application/json
Transfer-Encoding: chunked
Date: Fri, 14 Feb 2020 03:39:07 GMT

{
    "attackPower": 1.0,
    "attackType": "slashing",
    "description": "blah",
    "id": "01c5cb0c-ad18-4e7c-8e7e-9799b27476a3",
    "name": "test",
    "specialAbility": "none",
    "type": "sword",
    "weight": 10.0
}
```

The third feature allows users to update a specific weapon in the database table by executing a `PUT` HTTP operation on the `/weapons/{weaponId}` endpoint, setting the `Content-Type` header to `application/json` and the `Accept` header to `application/json`. The application responds with a 200 OK HTTP code and a JSON response body of the updated weapon data now stored in the database. Below is an example request and response.

Example Using cURL
```
curl -vvv -X PUT \
-H "Content-Type: application/json" \
-H "Accept: application/json" \
-d '{"name": "test", "type": "sword", "description": "blah", "attackPower": 2.0, "attackType": "slashing", "specialAbility": "none", "weight": 13.0}' \
http://localhost:8080/weapons/01c5cb0c-ad18-4e7c-8e7e-9799b27476a3
```

Request
```
PUT http://localhost:8080/weapons/01c5cb0c-ad18-4e7c-8e7e-9799b27476a3
Content-Type: application/json
Accept: application/json

{
    "name": "test",
    "type": "sword",
    "description": "blah",
    "attackPower": 2.0,
    "attackType": "slashing",
    "specialAbility": "none",
    "weight": 13.0
}
```

Response
```
HTTP/1.1 200
Content-Type: application/json
Transfer-Encoding: chunked
Date: Fri, 14 Feb 2020 03:47:09 GMT

{
    "attackPower": 2.0,
    "attackType": "slashing",
    "description": "blah",
    "id": "01c5cb0c-ad18-4e7c-8e7e-9799b27476a3",
    "name": "test",
    "specialAbility": "none",
    "type": "sword",
    "weight": 13.0
}
```

The fourth feature allows users to delete a specific weapon from the database table by executing a `DELETE` HTTP operation on the `/weapons/{weaponId}` endpoint. The application responds with a 204 NO CONTENT HTTP code with no response body. Below is an example request and response.

Example Using cURL
```
curl -vvv -X DELETE http://localhost:8080/weapons/01c5cb0c-ad18-4e7c-8e7e-9799b27476a3
```

Request
```
DELETE http://localhost:8080/weapons/01c5cb0c-ad18-4e7c-8e7e-9799b27476a3
```

Response
```
HTTP/1.1 204
Date: Fri, 14 Feb 2020 03:53:22 GMT
```

## Dependencies
- Linux
  - OpenJDK 11.0.6.j9
  - Docker
- Mac OS X
  - Xcode
  - Brew
  - OpenJDK 11.0.6.j9
  - Docker
- Windows
  - OpenJDK 11.0.6.j9
  - Docker Toolbox or Docker for Windows
  - Git

## Dev Environment
Once you have Docker and OpenJDK installed run the command `bash bootstrap_dev.sh` to setup your dev environment. After that has finished running, you can run make docker-up to start the application in the foreground or `docker-compose up -d` to run it in the background. You can see all running Docker containers with the comand `docker ps`.

If you would prefer not to run the application in Docker you will still need a local PostgreSQL database. The application is configured to use the following environment variables to connect to the database, and they will need to be set in order for it to run properly: `DB_CONNECTION_STRING`, `DB_USER`, and `DB_PASSWORD`.

Here is an example of how you would set this in a Linux or Mac OS X environment.
```
export DB_CONNECTION_STRING=jdbc:postgresql://localhost:5432/rpgd-dev
export DB_USER=<username>
export DB_PASSWORD=<password>
```

If you are using an IDE to run your application, you will need to set these environment variables in your IDE.

### Windows Docker Toolbox
If you are using Docker Toolbox on Windows there are a few gotchas we've ran into.
- You will need to run the commands from a network that isn't the TTU network in order to download the Java 11 and PostgreSQL images.
- In Docker Toolbox, localhost is 192.168.99.100, so to test you will need to make all HTTP requests to `http://192.168.99.100:8080`.

### Windows Command Line
If you are using an edition of Windows 10 that can run Docker without using Docker Toolbox, such as Windows 10 Pro, you will not be able to use the `bootstrap_windows_dev.sh` bash script without installing the Linux subsystem for Windows. Instead, you will need to run every command in the bootstrap script manually, and you will need to replace `./gradlew bootJar` with `./gradlew.bat bootJar`.

## Contributing
Please follow the [AngularJS commit guidelines](https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#commits) when committing code to the project.

All code changes need to be made on a separate branch following a naming convention of `CS3365-<summary-of-changes>`. In order to create a branch, use the following command:
```
git checkout -b CS3365-<summary-of-changes>
```

You can push these changes to GitHub with these commands:
```
git add .
git commit -am "<change-type>(<thing-changed>): <brief summary of changes>"
git push -u origin CS3365-<summary-of-changes>
```

Once you have pushed once with the arguments `-u origin CS3365-<summary-of-changes>`, you can just use `git push` from that point forward.

All code changes must go through a pull request process with at least one approver from the team. Written code must be tested, even if the tests are sparse.

In order to run the tests, use the command `make test` if on Linux or Mac OS X, or `./gradlew.bat cleanTest test` if on Windows.
